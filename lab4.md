## 1. Таймеры в современных ОС, их назначение и какие подходят для планировщика
### Какие таймеры существуют

В архитектуре x86 и реальных ОС есть несколько типов таймеров:

- a) PIT — Programmable Interval Timer (8253/8254)

Очень старый таймер, периодически генерирует прерывания.

Частота — до ~1 кГц.

Использовался в ранних Unix/Linux/Windows.

Сегодня устарел, используется редко.

- b) RTC — Real-Time Clock (как твоё M48T86)

Дает время/дату, может генерировать периодические прерывания (2 Hz – 8 kHz).

Слишком медленный/дорогой по доступу для планировщика.

Сегодня используется только как источник реального времени.

- c) HPET — High Precision Event Timer

Современный таймер с высокой точностью (до наносекунд).

Предоставляет несколько независимых таймеров-каналов.

Аппаратная поддержка в чипсете.

Можно программировать на точные моменты времени.

Подходит для high-resolution timers.

- d) APIC timer / LAPIC timer

Local APIC Timer — встроен в каждый CPU core.

Позволяет поставить таймер на конкретный поток/ядро.

Может работать как периодический, так и one-shot.

Частота зависит от TSC.

Это сейчас основной таймер планировщика в Linux/Windows.

- e) TSC — Time Stamp Counter

Счетчик тиков CPU, растёт равномерно.

Читается обычной инструкцией RDTSC → очень быстро.

Но сам по себе не генерирует прерываний, поэтому для планировщика нужен только в сочетании с APIC/HPET.

### Какие применяются для планировщика сейчас и почему

Современные ОС (Linux, Windows) используют:

- ✔ Local APIC timer

Идеален для пер-CPU таймеров.

Позволяет планировать события на каждом ядре отдельно.

Дает возможность отказаться от глобального периодического тика (tickless kernel).

- ✔ HPET

Используется, когда APIC недоступен или недостаточно точен.

Часто работает как источник времени для high-resolution timers.

RTC и PIT больше НЕ используются для планирования.

Они слишком медленные, занимают шину, плохо подходят для SMP и энергосбережения.

## 2. Почему прерывания таймера отключают в системном вызове и когда включают обратно
### Вход в системный вызов — cli

Когда начинается обработка системного вызова (например, sys_yield):

cli


Отключает прерывания.
Это делается, чтобы:

Гарантировать атомарность критической секции в ядре.

Предотвратить race condition с планировщиком и таймером.

Например, если во время изменения current->state или стека ядра придёт таймерное прерывание — возможна порча состояния.

### Где включают обратно

Прерывания включаются:

➡️ при выходе из системного вызова, в эпилоге trap handler-а

То есть перед возвратом в userspace:

iretq
↑ восстанавливает флаги, включая IF=1


Иначе пользовательский код никогда не получит прерывания.

### Включены ли прерывания внутри обработчика прерываний?

Нет. Никогда.

Когда происходит аппаратное прерывание:

CPU автоматически сбрасывает флаг IF.

То есть внутри interrupt handler-а прерывания всегда отключены.

Почему?

Чтобы сам обработчик не был прерван таким же или другим прерыванием.

Чтобы не возникло рекурсии/переполнения стека.

Чтобы обеспечить консистентность общих структур ядра.

### Может ли возникнуть то же прерывание внутри обработчика, если прерывания разрешены?

Теоретически — да, если бы IF=1.

На практике:

Повторное прерывание приводит к спурионному прерыванию, дублирующему вызову обработчика, переполнению стека и краху.

Поэтому архитектура x86 само запрещает дальнейшие IRQ, пока выполняется ISR.

## 3. PMIO, MMIO, DMA. Преимущества, недостатки, когда что использовать
### PMIO — Port-Mapped I/O

Доступ к устройствам через специальные порты:

inb/outb/inw/outw


Используется отдельное пространство адресов 0–65535.

Преимущества PMIO:

Простая логика устройств.

Четкое разделение RAM <> I/O.

Недостатки:

Нужно отдельные инструкции — хуже для оптимизации.

Не все архитектуры поддерживают — не portable.

Медленнее (в большинстве CPU).

### MMIO — Memory-Mapped I/O

Устройство отображается в виртуальную память и доступ идёт как:

*(volatile uint32_t*)addr = value;

Преимущества:

Единый механизм доступа (через load/store).

Можно использовать кеши/оптимизацию (частично).

Позволяет работать с device registers как с памятью.

Недостатки:

Нужно аккуратно запрещать оптимизации (volatile).

Возможны проблемы с порядком операций (barriers).

### DMA — можно ли использовать как единственный механизм I/O?
Нет.

DMA не может заменить всё:

DMA хорошо подходит только для:

больших блочных передач — диски, сеть, USB, GPU.

«перекачай буфер из A в B».

DMA не может:

управлять устройством (нужно программировать регистры через MMIO/PMIO),

обрабатывать события,

реагировать на прерывания,

выполнять мелкие операции (например, байт UART).

DMA = механизм передачи данных, а не управления.

Когда использовать polled I/O, а когда прерывания
### Polled I/O (polling) — активно спрашиваем устройство:
while (!(status & READY)) ;

Использовать, когда:

устройство очень быстро отвечает,

нужно минимальная задержка,

используется в раннем буте (до прерываний),

небольшие объемы данных,

ISR слишком дорогой.

Пример: чтение PS/2 клавиатуры в BIOS.

### Interrupt-driven I/O

Устройство сообщает, что событие произошло.

Использовать, когда:

событий мало или нерегулярно,

данные приходят по мере готовности,

высокие нагрузки (сетевой стек),

экономия CPU-time.




## Задание №1
Допишите вспомогательные функции для наботой с CMOS/регистрами RTC (cmos_read8() и cmos_write8()). Обратите внимание на то, что после обращения к выбранному регистру CMOS, номер регистра сбрасывается на нулевой.
### Что происходит и зачем
CMOS → это просто регистровое ОЗУ RTC, которое видно как 128 байт:
> “INTERFACED WITH SOFTWARE AS 128 RAM LOCATIONS: – 14 Bytes of Clock and Control Registers – 114 Bytes of General Purpose RAM” (rtc.md, L13–L16).
Регистры A–D и все время/дату/алярмы мы видим как байты по адресам 0–13 (карта адресов):
> “The address map of the M48T86 is shown… 114 bytes of user RAM, 10 bytes … and 4 bytes which are used for control and status… Registers C & D are ‘Read only’.” (rtc.md, L711–L718, L773–L776).
Поэтому cmos_read8/cmos_write8 делают строго: выбрать адрес (портом адреса), затем читать/писать данные; при этом регистровое окно “уходит” обратно, поэтому каждый раз нужно заново выбирать номер. Это соответствует общей логике “bus interface” с AD0–AD7 и управляющими сигналами (rtc.md, L455–L463, L471–L475).
## Задание №2
С помощью разработанных в первом задании функций выведите содержимое CMOS-памяти в команде монитора dumpcmos. Для того, чтобы войти в монитор, временно добавьте вызов assert(false) в начало выполнения кода ядра.
### Что происходит и зачем
CMOS содержит не только время, но и всю конфигурацию RTC и 114 байт произвольной RAM:
> “10 bytes of RAM that contain the RTC time, calendar and alarm data, and 4 bytes which are used for control and status… 114 bytes of user RAM” (rtc.md, L711–L715, L801–L805).
Команда dumpcmos даёт вам “сырое” состояние всех байт: можно проверить, что регистры A/B/C/D инициализировались как ожидается, PIE включён, частота выбрана правильно и т.д.
Это особенно важно перед настройкой периодических прерываний, потому что битовые поля регистров A и B кодируют частоту и включение прерываний (см. таблицы Register A/B: rtc.md, L1089–L1092 и L1182–L1184).
## Задание №3
Необходимо дописать в файле kern/kclock.c недостающий код функций rtc_timer_init(), в которой происходит инициализация часов rtc, и rtc_check_status, в которой происходит проверка статуса часов. Алгоритм инициализации выглядит следующим образом:
Переключение на регистр часов B.
Чтение значения регистра B из порта ввода-вывода.
Установка бита RTC_PIE.
Запись обновленного значения регистра в порт ввода-вывода.
Для проверки статуса часов в функции rtc_check_status() необходимо прочитать значение регистра часов C.
### Что происходит и зачем
Включаем периодические прерывания через бит PIE в Register B:
> “PIE: Periodic Interrupt Enable… When the PIE Bit is set to ‘1,’ periodic interrupts are generated… at a rate specified by the RS3–RS0 bits of Register A.” (rtc.md, L1110–L1117, L1119–L1123).
Регистры-статусы (флаги прерываний) находятся в Register C, их нужно читать именно оттуда:
> “When an interrupt event occurs, the related flag bit (Register C; Bit 6 = PF; Bit 5 = AF; Bit 4 = UF) is set… The interrupt flag bits are status bits which software can interrogate as necessary.” (rtc.md, L839–L846).
rtc_check_status() читает Register C, чтобы вы узнать, какое событие произошло, и одновременно подготовить RTC к следующему прерыванию (см. подробнее в Задании 6).
## Задание №4
Во время выполнения кода ядра ОC прерывания на процессоре должны быть замаскированы. Это является архитектурной особенностью ядра JOS. Для этого необходимо расставить в файле kern/entry.S в нужных местах три инструкции cli, которые осуществляют маскирование прерываний.
### Что происходит и зачем
RTC выдаёт сигнал IRQ на линию прерываний:
> “IRQ (Interrupt Request Output)… used as an interrupt input to a processor. The IRQ output remains low as long as the status bit causing the interrupt is present… IRQ returns to a high impedance state whenever Register C is read.” (rtc.md, L508–L517).
Пока ядро только стартует/меняет стек/заходит в обработчик, обрабатывать внешние прерывания небезопасно, поэтому JOS архитектурно требует cli (IF=0) вокруг этих участков.
Идея: пока не готовы к полноценной обработке IRQ, держим процессор с замаскированными прерываниями, а включением/маскированием PIC и чтением Register C управляем, когда именно начинаем участвовать в протоколе RTC/PIC.
## Задание №5
После инициализации часов RTC и программируемого контроллера прерываний PIC в функции rtc_timer_pic_interrupt() необходимо размаскировать на контроллере линию IRQ_CLOCK, по которой приходят прерывания от часов. Для этого можно использовать функцию pic_irq_unmask(). Для обработки прерываний следует настроить соответствующий вектор в таблице IDT в функции trap_init(). Обработчик находится в файле trapentry.S
### Что происходит и зачем
RTC формирует IRQ-сигнал всегда одинаково, но на процессор он попадёт только если PIC пропускает нужную линию; это как “второй уровень маскировки”.
Когда PIE=1 и частота выбрана, каждый периодический тик поднимает PF и формирует IRQ:
> “The periodic interrupt will cause the IRQ pin to go to an active state from once every 500ms to once every 122μs… The periodic interrupt is enabled by the PIE Bit (Register B; Bit 6).” (rtc.md, L904–L918).
Поэтому в rtc_timer_pic_interrupt() вы говорите PIC: “эту линию с RTC (IRQ_CLOCK) больше не глуши” (unmask), а в trap_init() настраиваете IDT так, чтобы это IRQ-номер приходил в ваш обработчик, который дальше уже вызовет rtc_timer_pic_handle() и sched_yield().
## Задание №6
После того, как прерывание сгенерировано и обработано, перед вызовом планировщика необходимо прочесть регистр статуса RTC и отправить сигнал EOI на контроллер прерываний, сигнализируя об окончании обработки прерывания. Иначе дальнейшие прерывания от часов не будут генерироваться PIC. Для этого можно использовать функции rtc_check_status(), pic_send_eoi().
### Что происходит и зачем
Ключевой момент спецификации: все флаги в Register C и сам IRQF очищаются при чтении Register C:
> “All bits which are set high are cleared when read… The act of reading Register C clears all active flag bits and the IRQF Bit.” (rtc.md, L850–L855, L873–L875).
Пока PF/IRQF остаются =1, RTC продолжает “держать” линию IRQ активной:
> “The IRQ output remains low as long as the status bit causing the interrupt is present… IRQ returns to a high impedance state whenever Register C is read.” (rtc.md, L511–L517).
Поэтому rtc_check_status() (чтение Register C) + pic_send_eoi() вместе выполняют протокол “я обработал тик, можно генерировать следующий”: RTC сбрасывает свои флаги, PIC получает EOI и готов принять новое IRQ.
## Задание №7
В данный момент часы реального времени работают на некой стандартной частоте. Измените процедуру rtc_timer_init так, чтобы прерывания от часов приходили один раз в полсекунды. Для этого необходимо изменить делитель частоты, которому соответствуют младшие 4 бита регистра часов A.
Что происходит и зачем
Частота периодического прерывания выбирается RS3–RS0 в Register A, и таблица даёт точные периоды:
> “These four rate-selection bits select one of the 13 taps on the 15-stage divider… Table 4 lists the periodic interrupt rates…” (rtc.md, L1070–L1075, L1083–L1085).
> “Table 4… RS3 RS2 RS1 RS0… 1111 → Periodic Interrupt: 2 Hz, 500ms” (rtc.md, L1027–L1045).
Для 500 мс нужно выбрать комбинацию RS3–RS0, соответствующую 2 Hz / 500ms (это последняя строка таблицы: 1111).
Ваша rtc_timer_init() именно этим и занимается: берёт текущее значение Register A, заменяет младшие 4 бита (RS3–RS0) на код 500 мс, и записывает его обратно, чтобы аппаратный делитель M48T86 генерировал тик ровно раз в полсекунды.