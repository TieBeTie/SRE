# Лабораторная работа №5: Поддержка HPET и синхронизация

## Обзор

В данной лабораторной работе реализуется поддержка таймера HPET (High Precision Event Timer) для замены RTC в планировщике задач, синхронизация аллокатора памяти с помощью спинлоков, а также секундомер на основе TSC (Time Stamp Counter).

---

## Задание №1: Доступ к таблицам ACPI (RSDP/RSDT/XSDT/FADT/HPET)

### Описание задачи

Для реализации поддержки HPET необходимо получить доступ к таблицам ACPI (Advanced Configuration and Power Interface). Система ACPI использует иерархическую структуру таблиц для описания аппаратных ресурсов системы. Корневой указатель RSDP (Root System Description Pointer) содержит адреса каталогов таблиц RSDT (32-битные адреса) или XSDT (64-битные адреса), которые в свою очередь содержат указатели на конкретные таблицы, такие как FADT (Fixed ACPI Description Table) и HPET.

### Реализация

**Файлы:** `kern/timer.c`, `kern/timer.h`

**Функции для реализации:**

1. **`get_rsdp()`** — получение корневого указателя RSDP
   - Использует адрес из `uefi_lp->ACPIRoot`, который передается загрузчиком
   - Маппит физический адрес RSDP в виртуальное пространство ядра через `mmio_map_region`
   - Возвращает указатель на структуру RSDP

2. **`find_acpi_table(const char *sign)`** — универсальная функция поиска ACPI таблицы по сигнатуре
   - Получает RSDP через `get_rsdp()`
   - Проверяет сигнатуру RSDP ("RSD PTR ")
   - Определяет наличие XSDT (при Revision >= 2) или RSDT (для обратной совместимости)
   - Перебирает массив адресов таблиц в RSDT/XSDT
   - Для каждой таблицы:
     - Маппит заголовок таблицы (ACPISDTHeader) для проверки сигнатуры
     - Сравнивает сигнатуру с искомой (4 байта, например "HPET", "FACP")
     - Если совпадает, маппит всю таблицу через `mmio_remap_last_region` (используя поле Length из заголовка)
     - Проверяет контрольную сумму (сумма всех байтов таблицы должна быть равна нулю)
     - Возвращает указатель на найденную таблицу

3. **`get_fadt()`** — получение таблицы FADT
   - Использует `find_acpi_table("FACP")` (сигнатура FADT — "FACP", а не "FADT")
   - Возвращает указатель на структуру FADT

4. **`get_hpet()`** — получение таблицы HPET
   - Использует `find_acpi_table("HPET")`
   - Возвращает указатель на структуру HPET, которая содержит физический адрес регистров HPET

### Ключевые моменты

- Приоритет XSDT над RSDT: согласно спецификации ACPI, если присутствует XSDT (Revision >= 2), его необходимо использовать вместо RSDT
- Двухэтапный маппинг: сначала маппится только заголовок для проверки сигнатуры, затем вся таблица на основе поля Length
- Проверка контрольной суммы обязательна для валидации целостности таблицы

---

## Задание №2: Поддержка HPET таймеров hpet0/hpet1 и интеграция с IDT

### Описание задачи

HPET (High Precision Event Timer) предоставляет несколько независимых таймеров, которые можно настроить для генерации периодических прерываний. В данном задании необходимо реализовать поддержку двух таймеров HPET (hpet0 и hpet1) с периодами 0.5 и 1.5 секунд соответственно. Для упрощения используется режим LegacyReplacement, который автоматически маршрутизирует прерывания на линии IRQ0 (для hpet0) и IRQ8 (для hpet1), заменяя PIT и RTC соответственно.

### Реализация

**Файлы:** `kern/timer.c`, `kern/timer.h`, `kern/trap.c`, `kern/trapentry.S`

**Функции для реализации:**

1. **`hpet_init()`** — инициализация HPET
   - Получает таблицу HPET через `get_hpet()`
   - Извлекает физический адрес регистров HPET из поля `address.address`
   - Маппит регистры HPET в память через `mmio_map_region`
   - Читает регистр GCAP_ID для получения периода счетчика в фемтосекундах
   - Вычисляет частоту HPET: `hpetFreq = 1 Peta / hpetFemto`
   - Проверяет поддержку LegacyReplacement режима (бит HPET_LEG_RT_CAP)
   - Включает главный счетчик HPET (устанавливает бит HPET_ENABLE_CNF в GEN_CONF)

2. **`hpet_enable_interrupts_tim0()`** — настройка таймера 0 (hpet0)
   - Вызывает `hpet_init()` для инициализации (если еще не инициализирован)
   - Останавливает главный счетчик (сбрасывает HPET_ENABLE_CNF) для безопасной переконфигурации
   - Включает режим LegacyReplacement (устанавливает HPET_LEG_RT_CNF в GEN_CONF)
   - Настраивает TIM0_CONF:
     - Включает прерывания (HPET_TN_INT_ENB_CNF)
     - Включает периодический режим (HPET_TN_TYPE_CNF)
     - Включает установку значения (HPET_TN_VAL_SET_CNF) для перезагрузки компаратора
   - Вычисляет значение компаратора для периода 0.5 секунды: `delta = hpetFreq / 2`
   - Сбрасывает главный счетчик в 0
   - Устанавливает TIM0_COMP в вычисленное значение delta
   - Включает главный счетчик обратно
   - Размаскирует прерывание IRQ_TIMER в PIC через `pic_irq_unmask(IRQ_TIMER)`

3. **`hpet_enable_interrupts_tim1()`** — настройка таймера 1 (hpet1)
   - Аналогично hpet0, но:
     - Настраивает TIM1_CONF вместо TIM0_CONF
     - Период 1.5 секунды: `delta = (hpetFreq * 3) / 2`
     - Размаскирует IRQ_CLOCK вместо IRQ_TIMER

4. **`hpet_handle_interrupts_tim0()`** — обработка прерывания от hpet0
   - Отправляет сигнал EOI (End of Interrupt) в PIC для IRQ_TIMER через `pic_send_eoi(IRQ_TIMER)`

5. **`hpet_handle_interrupts_tim1()`** — обработка прерывания от hpet1
   - Отправляет сигнал EOI для IRQ_CLOCK через `pic_send_eoi(IRQ_CLOCK)`

**Интеграция с IDT и обработкой прерываний:**

1. **В `trap_init()`** (файл `kern/trap.c`):
   - Добавить регистрацию обработчика прерывания для IRQ_TIMER:
     ```c
     extern void timer_thdlr(void);
     idt[IRQ_OFFSET + IRQ_TIMER] = GATE(0, GD_KT, timer_thdlr, 0);
     ```
   - Обработчик `timer_thdlr` уже определен в `kern/trapentry.S`

2. **В `trap_dispatch()`** (файл `kern/trap.c`):
   - Заменить прямую обработку прерываний RTC на использование абстракции таймера:
     ```c
     case IRQ_OFFSET + IRQ_TIMER:
     case IRQ_OFFSET + IRQ_CLOCK:
         timer_for_schedule->handle_interrupts();
         sched_yield();
         return;
     ```
   - Оба прерывания (IRQ_TIMER и IRQ_CLOCK) обрабатываются одинаково через единый интерфейс

### Ключевые моменты

- LegacyReplacement режим автоматически маршрутизирует прерывания: hpet0 → IRQ0 (IRQ_TIMER), hpet1 → IRQ8 (IRQ_CLOCK)
- Главный счетчик должен быть остановлен перед переконфигурацией таймеров для избежания состояний гонки
- Периодический режим требует установки бита HPET_TN_VAL_SET_CNF для автоматической перезагрузки компаратора

---

## Задание №3: Выбор таймера и проверка планировщика

### Описание задачи

Система должна поддерживать выбор различных таймеров для планировщика задач. В массиве `timertab` регистрируются все доступные таймеры (rtc, pit, pm, hpet0, hpet1), а функция `timers_schedule` позволяет выбрать конкретный таймер по имени для использования в планировщике.

### Реализация

**Файлы:** `kern/init.c`, `kern/timer.c`, `kern/timer.h`

**Функции для реализации:**

1. **`timers_init()`** — инициализация всех таймеров
   - Заполняет массив `timertab` структурами таймеров:
     ```c
     timertab[0] = timer_rtc;
     timertab[1] = timer_pit;
     timertab[2] = timer_acpipm;
     timertab[3] = timer_hpet0;
     timertab[4] = timer_hpet1;
     ```
   - Для каждого таймера вызывает `timer_init()` (если функция определена) для инициализации

2. **`timers_schedule(const char *name)`** — выбор таймера для планировщика
   - Ищет таймер в массиве `timertab` по имени (например, "rtc", "hpet0", "hpet1")
   - Проверяет, что у таймера есть функция `enable_interrupts` (поддержка прерываний)
   - Устанавливает глобальный указатель `timer_for_schedule` на выбранный таймер
   - Вызывает `enable_interrupts()` выбранного таймера для активации прерываний

**Использование в `i386_init()`:**

- Вызывается `timers_init()` для инициализации всех таймеров
- Вызывается `timers_schedule("hpet0")` (или другой таймер) для выбора таймера планировщика

### Проверка

После реализации необходимо убедиться, что планировщик корректно работает со всеми поддерживаемыми таймерами:
- `rtc` — таймер RTC (реализован ранее)
- `hpet0` — HPET таймер 0 с периодом 0.5 секунды
- `hpet1` — HPET таймер 1 с периодом 1.5 секунды

---

## Задание №4: Синхронизация аллокатора (spinlock в alloc.c)

### Описание задачи

При параллельной работе нескольких процессов с одной и той же областью памяти могут возникать состояния гонки (race conditions). В случае с аллокатором памяти процессы могут одновременно обращаться к списку свободных страниц, что может привести к его повреждению. Для предотвращения таких ситуаций необходимо использовать спинлоки (spinlocks) — примитивы синхронизации с активным ожиданием.

### Реализация

**Файлы:** `kern/alloc.c`, `kern/spinlock.c`, `kern/spinlock.h`

**Шаги реализации:**

1. **Инициализация спинлока:**
   - Объявить статическую переменную спинлока: `static struct spinlock alloc_lock;`
   - Инициализировать спинлок (обычно через макрос `spin_initlock` или функцию `__spin_initlock`)

2. **Защита функции `test_alloc()`:**
   - В начале функции вызвать `spin_lock(&alloc_lock)` для захвата блокировки
   - В конце функции (перед всеми точками возврата) вызвать `spin_unlock(&alloc_lock)` для освобождения блокировки
   - Важно: блокировка должна быть снята во всех путях выполнения функции (включая ранние возвраты)

3. **Защита функции `test_free()`:**
   - Аналогично `test_alloc()`, обернуть всю логику работы со списком свободных блоков в `spin_lock`/`spin_unlock`

### Ключевые моменты

- Спинлоки используют активное ожидание (busy-waiting), поэтому не должны удерживаться долго
- Блокировка должна быть снята во всех путях выполнения, иначе возможен deadlock
- Ошибка "Corrupted list" возникает при повреждении связного списка из-за состояния гонки
- Уменьшение периода таймера увеличивает частоту переключения процессов и вероятность возникновения race condition

---

## Задание №5: Вычисление частоты CPU по HPET и ACPI PMTimer

### Описание задачи

Для работы секундомера на основе TSC необходимо знать частоту процессора. Частоту можно вычислить, сравнив дельту счетчика TSC с дельтой известного таймера (HPET или ACPI Power Management Timer). HPET имеет известную частоту, которая извлекается из регистра GCAP_ID, а ACPI PMTimer работает на фиксированной частоте 3.579545 MHz.

### Реализация

**Файлы:** `kern/timer.c`, `kern/timer.h`

**Функции для реализации:**

1. **`hpet_cpu_frequency()`** — вычисление частоты CPU с помощью HPET
   - Вызывает `hpet_init()` для инициализации HPET (если еще не инициализирован)
   - Сохраняет состояние прерываний и отключает их (`cli`) для атомарности измерений
   - Читает начальное значение главного счетчика HPET: `c1 = hpetReg->MAIN_CNT`
   - Читает начальное значение TSC: `t1 = read_tsc()`
   - Ждет, пока пройдет достаточно времени (например, 1/10 секунды): `threshold = hpetFreq / 10`
   - В цикле читает `MAIN_CNT` до тех пор, пока разница не превысит threshold
   - Читает конечное значение TSC: `t2 = read_tsc()`
   - Восстанавливает состояние прерываний (`sti`, если были включены)
   - Вычисляет частоту: `cpu_freq = (tsc_delta * hpetFreq) / timer_delta`
   - Кэширует результат в статической переменной для последующих вызовов

2. **`pmtimer_cpu_frequency()`** — вычисление частоты CPU с помощью ACPI PMTimer
   - Получает FADT через `get_fadt()` для доступа к адресу PMTimerBlock
   - Сохраняет состояние прерываний и отключает их
   - Читает начальное значение PMTimer: `t1 = pmtimer_get_timeval()` (использует `inl(fadt->PMTimerBlock)`)
   - Читает начальное значение TSC: `tsc1 = read_tsc()`
   - Делает небольшую паузу (`pause` инструкция)
   - Читает конечные значения: `t2 = pmtimer_get_timeval()`, `tsc2 = read_tsc()`
   - Восстанавливает состояние прерываний
   - Обрабатывает возможное переполнение счетчика PMTimer:
     - Если `t2 > t1`: нет переполнения, `timer_delta = t2 - t1`
     - Если `t1 - t2 <= 0x00FFFFFF`: переполнение 24-битного счетчика, `timer_delta = 0x00FFFFFF - t1 + t2`
     - Иначе: переполнение 32-битного счетчика, `timer_delta = UINT32_MAX - t1 + t2`
   - Обрабатывает возможное переполнение TSC (аналогично)
   - Вычисляет частоту: `cpu_freq = (tsc_delta * PM_FREQ) / timer_delta`, где `PM_FREQ = 3579545` (3.579545 MHz)
   - Кэширует результат

### Ключевые моменты

- Измерения должны быть атомарными (прерывания отключены) для точности
- PMTimer может быть 24-битным или 32-битным, необходимо корректно обрабатывать переполнение
- TSC также может переполняться (хотя это маловероятно для 64-битного счетчика)
- Чем больше интервал измерения, тем точнее результат

---

## Задание №6: Секундомер на TSC и команды монитора

### Описание задачи

Реализовать секундомер на основе TSC (Time Stamp Counter) — 64-битного регистра процессора, который содержит число тактов с последнего сброса. Зная частоту процессора и количество тактов между двумя моментами времени, можно вычислить прошедшее время. Также необходимо добавить команды в монитор для удобного тестирования.

### Реализация

**Файлы:** `kern/tsc.c`, `kern/tsc.h`, `kern/monitor.c`, `kern/init.c`

**Функции для реализации:**

1. **`timer_start(const char *name)`** — запуск секундомера
   - Принимает имя таймера для измерения частоты CPU ("pit", "hpet0", "hpet1", "pm")
   - Выбирает соответствующую функцию измерения частоты:
     - "pit" → `tsc_calibrate()` (уже реализована)
     - "hpet0" или "hpet1" → `hpet_cpu_frequency()`
     - "pm" → `pmtimer_cpu_frequency()`
   - Сохраняет полученную частоту в статической переменной
   - Сохраняет текущее значение TSC через `read_tsc()` в статической переменной
   - Устанавливает флаг `timer_started = true`

2. **`timer_stop()`** — остановка секундомера и вывод результата
   - Проверяет, что секундомер был запущен (`timer_started == true`), иначе выводит ошибку через `print_timer_error()`
   - Читает текущее значение TSC: `now = read_tsc()`
   - Вычисляет дельту: `delta = now - timer` (обрабатывает возможное переполнение, если `now < timer`)
   - Проверяет, что частота была получена (`freq != 0`), иначе выводит ошибку
   - Вычисляет прошедшее время в секундах: `seconds = delta / freq`
   - Выводит результат через `print_time(seconds)`
   - Сбрасывает флаг `timer_started = false`

3. **`timer_cpu_frequency(const char *name)`** — вывод частоты CPU для указанного таймера
   - Принимает имя таймера
   - Вызывает соответствующую функцию измерения частоты (аналогично `timer_start`)
   - Выводит частоту в Герцах через `print_time(freq)`

**Команды монитора:**

В файле `kern/monitor.c` добавить обработчики команд:

1. **`mon_start(int argc, char **argv, struct Trapframe *tf)`** — команда `timer_start`
   - Проверяет наличие аргумента (имя таймера)
   - Вызывает `timer_start(argv[1])`

2. **`mon_stop(int argc, char **argv, struct Trapframe *tf)`** — команда `timer_stop`
   - Вызывает `timer_stop()`

3. **`mon_frequency(int argc, char **argv, struct Trapframe *tf)`** — команда `timer_freq`
   - Проверяет наличие аргумента
   - Вызывает `timer_cpu_frequency(argv[1])`

Зарегистрировать команды в массиве `commands`:
```c
{ "timer_start", "Start timer with specified timer name", mon_start },
{ "timer_stop", "Stop timer and print elapsed time", mon_stop },
{ "timer_freq", "Print CPU frequency for specified timer", mon_frequency },
```

**Отключение автозапуска программ:**

В файле `kern/init.c` в функции `i386_init()` закомментировать или удалить вызовы `ENV_CREATE` для бесконечно выполняющихся программ, чтобы система переходила в монитор после инициализации.

### Ключевые моменты

- TSC монотонно увеличивается (кроме переполнения 64-битного счетчика)
- Частота CPU должна быть измерена до запуска секундомера
- Обработка переполнения TSC необходима для корректной работы при длительных измерениях
- Команды монитора должны проверять наличие аргументов перед использованием

---

## Итоговая проверка

После выполнения всех заданий необходимо убедиться:

1. ✅ Система корректно работает с таймерами rtc, hpet0, hpet1
2. ✅ Планировщик задач переключает процессы с заданной частотой
3. ✅ Аллокатор памяти защищен от состояний гонки (нет ошибок "Corrupted list")
4. ✅ Секундомер корректно измеряет время с помощью различных таймеров
5. ✅ Команды монитора работают корректно

## Примечания

- В VirtualBox код подсчета частоты с PIT может некорректно работать (бесконечный цикл в `tsc_calibrate()`), в таком случае рекомендуется использовать другие таймеры (hpet0, hpet1, pm)
- При уменьшении периода таймера увеличивается вероятность возникновения race conditions, что помогает выявить проблемы синхронизации
- Все функции работы с ACPI таблицами должны проверять контрольные суммы для валидации целостности данных

