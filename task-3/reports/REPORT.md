# Выводы

Проведено нагрузочное тестирование API приложения для определения максимальной производительности системы и выявления узких мест. Нагрузка подавалась через HTTP запросы к ingress, что соответствует реальному сценарию использования.

**Максимальная производительность** была определена тестом с нагрузкой 600 VUs ([`scripts/load_test.js`](../scripts/load_test.js)): система обработала 717,968 успешных запросов (100% HTTP 200, 0% ошибок) с пропускной способностью **~878 RPS** ([`screenshots/max_rps.png`](screenshots/max_rps.png)). При этом p95 latency составил около 2s, что превышает SLO < 500ms (['screenshots/max_latency.png'](max_latency.png)), но все запросы были успешно обработаны.

**Точка насыщения** (максимальная производительность при соблюдении SLO) была определена тестом [`scripts/gradual_load_test.js`](../scripts/gradual_load_test.js) с нагрузкой 300 VUs: система показала **~620 RPS** ([`screenshots/sla_rps.png`](screenshots/sla_rps.png)) при p95 latency 77.9 ms (в пределах SLO < 500ms) ([`screenshots/sla_latency.png`](screenshots/sla_latency.png)) и 0% ошибок ([`screenshots/sla_error_rate.png`](screenshots/sla_error_rate.png)). 

Узкое место, это соединения к PostgreSQL. Анализ метрик показывает прямую корреляцию между ростом активных соединений к БД и ростом latency. Во время теста с нагрузкой 600 VUs (точка насыщения) число активных соединений к БД достигало 300, при этом p95 latency оставался в пределах SLO (77.9ms). Во время теста с нагрузкой 300 VUs (максимальная производительность) активные соединения достигали 223, а p95 latency увеличивался до ~2s ([`screenshots/max_latency.png`](screenshots/max_latency.png)), что указывает на конкуренцию за соединения к БД как основной фактор деградации производительности ([`screenshots/postgres_active_connections.png`](screenshots/postgres_active_connections.png)). CPU и память не являются ограничением: использование CPU на всех нодах составило всего 6.5% ([`screenshots/cpu_usage.png`](screenshots/cpu_usage.png)), что подтверждается метриками Node Exporter ([`screenshots/image copy.png`](screenshots/image%20copy.png)). 

Для масштабирования возможны следующие варианты оптимизации: использование connection pooler (PgBouncer) для переиспользования соединений, настройка размера пула соединений в приложении через параметры   connection string (MaxPoolSize), или горизонтальное масштабирование — увеличение количества реплик API при сохранении текущей конфигурации пула соединений.
